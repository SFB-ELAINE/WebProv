<template>
  <div>
    <!-- This is the main svg animation -->
    <d3
      ref="d3"
      :height="height"
      :width="width"
      :links="links"
      :nodes="nodes"
      force 
      zoom
      arrows
      drag
      :pan.sync="pan"
      hulls
      :hull-dblclick="hullDblclick"
      :color-changes="colorChanges"
    ></d3>
    
    <!-- This is the dashed line you see when creating new links -->
    <svg
      :height="height"
      :width="width"
      style="position: absolute; top: 0; left: 0; pointer-events: none;"
    >
      <line
        :x1="lineStart ? lineStart.x : 0"
        :y1="lineStart ? lineStart.y : 0"
        :x2="lineEnd ? lineEnd.x : 0"
        :y2="lineEnd ? lineEnd.y : 0"
        stroke-dasharray="4"
        stroke="black"
      ></line>
    </svg>

    <div class="overlay">
      
      <search-card
        class="search overlay-child" 
        :items="searchItems"
        @open="expandStudy"
        @dependency="showProvenanceGraph"
        @open-study="openStudy"
      ></search-card>
      <div style="flex: 1"></div>

      <b-button
        v-if="showEditTools"
        class="clear-button overlay-child"
        type="is-text"
        @click="createStudy"
      >
        Add Study
      </b-button>
      
      <b-button
        v-if="showEditTools"
        class="clear-button overlay-child"
        type="is-text"
        @click="addNode"
      >
        Add Node
      </b-button>

      <b-button
        v-if="showEditTools"
        class="clear-button overlay-child"
        type="is-text"
        @click="stopEdit"
      >
        Exit
      </b-button>

      <div class="cards overlay-child">

        <prov-legend-card v-bind="legendProps"></prov-legend-card>
        <div class="spacer"></div>

        <simulation-study-card
          v-if="selectedStudy"
          :study="selectedStudy"
          @cancel="cancelSelectedStudy"
          @delete="deleteSelectedStudy"
          @save="saveSelectedStudy"
        ></simulation-study-card>
        <div v-if="selectedStudy" class="spacer"></div>
        
        <select-card
          title="Relationship" 
          v-if="currentRelationship"
          :value="currentRelationship"
          @input="changeRelationship"
          :options="possibleRelationships"
          @close="cancelRelationshipSelection"
          @delete="deleteRelationship"
        ></select-card>
        <div class="spacer"></div>
        
        <node-form-card
          v-if="selectedNode"
          :node="selectedNode"
          :studies="simulationStudies"
          @close="deselectNode"
          @delete="deleteNode"
          @update="editNode"
        ></node-form-card>
      
      </div>
    </div>

    <information-modal
      v-model="showHelp"
    ></information-modal>

    <div class="version">v{{ version }}</div>

    <fab :actions="fabActions"></fab>

  </div>
</template>

<script lang="ts">
import {
  relationshipColors,
  NODE_OUTLINE,
  VALID_ENDPOINT_OUTLINE,
  INVALID_ENDPOINT_OUTLINE,
  NODE_HEIGHT,
  NODE_RADIUS,
  SIMULATION_STUDY_STROKE,
  SIMULATION_STUDY_WIDTH,
  SELECTED_NODE_OUTLINE,
} from '@/constants';
import {
  ProvenanceNodeType,
  ProvenanceNode,
  relationshipRules,
  DependencyType,
  provenanceNodeTypes,
  SimulationStudy,
  RelationshipInformation,
  uniqueId,
  tuple,
  TypeOf,
  DependencyRelationship,
  isValidRelationship,
} from 'common';
import ProvLegendCard from '@/components/ProvLegendCard.vue';
import InformationModal from '@/components/InformationModal.vue';
import D3 from '@/components/D3.vue';
import {
  Lookup,
  getLabel,
  makeLookup,
  addEventListeners,
  createRelationship,
  getDefaultRelationshipType,
  get,
  makeRequest,
  makeLookupBy,
  makeArrayLookupBy,
  isDefined,
  getLogger,
  createComponent,
  createModelVersionLookup,
  Connection,
  HighLevelNode,
  merge,
  getClassification,
  toTsv,
  TsvRow,
  download,
  zip,
  map,
} from '@/utils';
import { D3Hull, D3Node, D3Link, D3NodeColorCombo } from '@/d3';
import SearchCard from '@/components/SearchCard.vue';
import NodeFormCard from '@/components/NodeFormCard.vue';
import SimulationStudyCard from '@/components/SimulationStudyCard.vue';
import SelectCard from '@/components/SelectCard.vue';
import { SearchItem, search } from '@/search';
import * as backend from '@/backend';
import debounce from 'lodash.debounce';
import { version } from '../package.json';
import { computed, value, onMounted } from 'vue-function-api';
import Fab, { FabAction } from '@/components/Fab.vue';

interface BaseNode extends D3Node {
  studyId?: number;
  text: string;
}

interface GroupNode extends BaseNode {
  isGroup: true;
}

interface SingleNode extends BaseNode {
  provenanceNode: ProvenanceNode;
  isGroup: false;
  type: ProvenanceNodeType;
}

type Node = SingleNode | GroupNode;

interface Link extends D3Link {
  color: string;
}

interface Point {
  x: number;
  y: number;
}

export type RelationshipCache = {
  [A in ProvenanceNodeType]?: {
    [B in ProvenanceNodeType]?: DependencyType;
  };
};

const isSingleNode = (node: Node): node is SingleNode => {
  return !node.isGroup;
};

const logger = getLogger();

export default createComponent({
  name: 'Visualizer',
  components: {
    ProvLegendCard,
    D3,
    SearchCard,
    SelectCard,
    NodeFormCard,
    SimulationStudyCard,
    InformationModal,
    Fab,
  },
  props: {
    windowHeight: { type: Number, required: true },
    windowWidth: { type: Number, required: true },
  },
  setup(props, context) {
    // The package version number
    const provenanceNodes = value<ProvenanceNode[]>([]);
    const dependencies = value<Array<RelationshipInformation<DependencyRelationship>>>([]);

    // which studies are currently expanded
    const expanded = value<Lookup<boolean>>({});

    // The current nodes that are passed to D3
    const nodes = value<Node[]>([]);
    const links = value<Link[]>([]);

    const legendProps = {
      nodeOutline: NODE_OUTLINE,
      nodeRadius: NODE_RADIUS,
      simulationStudyOutline: SIMULATION_STUDY_STROKE,
    };

    // All of the nodes to show
    // If a node is in a group that isn't expanded, it will not actually be shown
    const nodesToShow = value<Lookup<boolean>>({});

    // Used when users click the "See more" button so that new nodes aren't placed at 0, 0
    // Instead, they are initially placed at the location of the clicked node
    const pointToPlaceNode = value({ x: 0, y: 0 });

    // Used when drawing line in edit mode
    const lineStart = value<Point | null>(null);
    const lineEnd = value<Point | null>(null);

    const selectedConnection = value<Connection | null>(null);
    const currentRelationship = value<DependencyType | null>(null);
    const possibleRelationships = value<DependencyType[] | null>(null);

    // used to display information on a card
    const selectedNode = value<ProvenanceNode | null>(null);

    // This lookup is used to cache selected connections
    // When a user change the type of relationship, new relatinoships that are created
    // will be of the cached type.
    const cachedConnections = value<RelationshipCache>({});

    const simulationStudies = value<SimulationStudy[]>([]);

    // Whether to show the help information
    const showHelp = value(false);

    // Whether to show the help information
    const showEditTools = value(false);

    // The pan of the visualization
    const pan = value({ x: 0, y: 0 });

    const exportNodes = () => {
      interface ExportRow {
        id: string;
        label: string;
        type: ProvenanceNodeType;
        studyId?: number;
        informationFields: Array<{ key: string, value: string }>;
        dependencies: Array<{ target: string, type: DependencyType }>;
      }

      const exportRows = Object.keys(nodesToShow.value).map((nodeId): ExportRow | undefined => {
        const show = nodesToShow.value[nodeId];
        if (!show) {
          return;
        }

        const highLevelNode = highLevelNodeLookup.value[nodeId];
        const node = highLevelNode.node;

        const connections = getConnections(node.id) || [];
        const nodeDependencies = connections.map((connection) => ({
          target: connection.target,
          type: connection.properties.type,
        }));

        const nodeInformationFields = map(zip(node.keys, node.values), ([k, v]) => {
          return {
            key: k,
            value: v,
          };
        });


        return {
          id: node.id,
          label: getLabel(node, simulationStudyLookup.value, modelVersionLookup.value),
          type: node.type,
          studyId: node.studyId,
          dependencies: nodeDependencies,
          informationFields: nodeInformationFields,
        };
      });

      const tsv = toTsv(exportRows.filter(isDefined) as any);
      download({
        filename: 'exported-provenance-nodes.tsv',
        text: tsv,
      });
    };

    const fabActions: FabAction[] = [
      {
        name: 'Clear Nodes',
        icon: 'clear_all',
        callback: () => {
          nodesToShow.value = {};
          renderGraph();
        },
      },
      {
        name: 'Export Graph as TSV',
        icon: 'cloud_download',
        callback: exportNodes,
      },
      {
        name: 'Show Help',
        icon: 'info',
        callback: () => {
          showHelp.value = true;
        },
      },
      {
        name: 'Show Editor Tools',
        icon: 'edit',
        callback: () => {
          showEditTools.value = true;
        },
      },
    ];

    // The selected study. This is set automatically when a new study is created or it can be opened from the search.
    const selectedStudy = value<SimulationStudy | null>(null);

    const debouncedRenderGraph = debounce(renderGraph, 500);
    const debouncedUpdateOrCreateNode = debounce((node: ProvenanceNode) => {
      return makeRequest(() => backend.updateOrCreateNode(node));
    }, 500);

    // Used to change the color of individual nodes without having to re-render the whole graph
    const colorChanges = value<D3NodeColorCombo[]>([]);

    const height = computed(() => {
      // OK, so for some reason we have to remove 7 here so that there is no overlow
      return props.windowHeight - 7;
    });

    const width = computed(() => {
      return props.windowWidth;
    });

    const nodeLookup = computed(() => {
      return makeLookup(nodes.value);
    });

    const highLevelNodes = computed((): HighLevelNode[] => {
      const lookup: Lookup<HighLevelNode> = {};
      provenanceNodes.value.forEach((node) => {
        lookup[node.id] = {
          id: node.id,
          node,
          incoming: [],
          outgoing: [],
        };
      });

      provenanceNodes.value.forEach((n) => {
        const sourceId = n.id;

        const source = lookup[sourceId];
        const connections = getConnections(sourceId);
        if (!connections) {
          return;
        }

        connections.forEach((connection) => {
          const targetId = connection.target;
          const target: HighLevelNode | undefined = lookup[targetId];
          if (!target) {
            context.root.$notification.open({
              duration: 10000,
              message: `Connection target not found: ${n.type}(${sourceId}) => ${targetId}`,
              position: 'is-top-right',
              type: 'is-warning',
            });
            return;
          }

          const d3Connection: Connection = {
            relationship: connection.properties.type,
            properties: connection.properties,
            original: connection,
            color: relationshipColors[connection.properties.type].color,
            source,
            target,
          };

          source.outgoing.push(d3Connection);
          target.incoming.push(d3Connection);
        });
      });

      return Object.values(lookup);
    });

    const highLevelNodeLookup = computed(() => {
      return makeLookup(highLevelNodes.value);
    });

    const simulationStudyLookup = computed(() => {
      return makeLookupBy(simulationStudies.value, (study) => study.studyId);
    });

    const dependenciesLookup = computed(() => {
      return makeArrayLookupBy(dependencies.value, (d) => d.source);
    });

    // lookup by studyId
    const sortedHighLevelNodes = computed(() => {
      const allNodes: { [studyId: number]: HighLevelNode[] } = {};
      highLevelNodes.value.forEach((highLevelNode) => {
        const studyId = highLevelNode.node.studyId;
        if (studyId === undefined) {
          return;
        }

        if (!allNodes[studyId]) {
          allNodes[studyId] = [];
        }

        allNodes[studyId].push(highLevelNode);
      });

      return Object.values(allNodes);
    });

    const modelVersionLookup = computed(() => {
      const lookups = sortedHighLevelNodes.value.map(createModelVersionLookup);
      // Since the IDs are used as keys, there will be no clashing when we merge objects
      return merge(lookups);
    });

    function getConnections(id: string) {
      if (!dependenciesLookup.value[id]) {
        return undefined;
      }
      return dependenciesLookup.value[id];
    }

    function showProvenanceGraph(r: SearchItem) {
      const showNode = (id: string) => {
        if (highLevelNodeLookup.value[id] === undefined) {
          return;
        }

        nodesToShow.value[id] = true;
        const info = highLevelNodeLookup.value[id];
        if (info.node.studyId !== undefined) {
          expanded.value[info.node.studyId] = true;
        }

        info.outgoing.forEach((c) => {
          showNode(c.target.id);
        });
      };

      if (highLevelNodeLookup.value[r.id] === undefined) {
        context.root.$notification.open({
          message: 'This node does not exist.',
          position: 'is-top-right',
          type: 'is-warning',
        });

        return;
      }

      showNode(r.id);
      renderGraph();
    }

    function cancelSelectedStudy() {
      selectedStudy.value = null;
    }

    async function saveSelectedStudy() {
      if (!selectedStudy.value) {
        return;
      }

      const study = selectedStudy.value;
      const result = await makeRequest(() => backend.updateOrCreateStudy(study));
      if (result.result === 'success') {
        selectedStudy.value = null;
        simulationStudies.value.push(study);
      }
    }

    async function deleteSelectedStudy() {
      if (!selectedStudy.value) {
        return;
      }

      const study = selectedStudy.value;
      const result = await makeRequest(() => backend.deleteStudy(study.id));
      if (result.result === 'success') {
        selectedStudy.value = null;
        const i = simulationStudies.value.indexOf(study);
        simulationStudies.value.splice(i, 1);
      }
    }

    function expandStudy(result: SearchItem) {
      if (result.studyId !== undefined) {
        expanded.value[result.studyId] = true;
      }

      highLevelNodes.value.forEach(({ node, id }) => {
        if (node.studyId === result.studyId) {
          nodesToShow.value[id] = true;
        }
      });

      renderGraph();
    }

    const searchItems = computed(() => {
      return highLevelNodes.value.map((n): SearchItem => {
        return {
          id: n.id,
          title: getLabel(n.node, simulationStudyLookup.value, modelVersionLookup.value),
          type: n.node.type,
          studyId: n.node.studyId,
          studyText: n.node.studyId !== undefined ? `Study ${n.node.studyId}` : undefined,
          extra: n.node.values,
        };
      });
    });

    async function createStudy() {
      const result = await makeRequest(() => backend.getMaxStudyId());
      if (result.result !== 'success') {
        return;
      }

      selectedStudy.value = {
        id: uniqueId(),
        // Once we have the max, we just add 1 to creat the new study ID
        // If we have concurrent users creating studies, this might cause issues
        // But this solution works for now
        studyId: result.item + 1,
      };
    }

    function nodeRightClick(e: MouseEvent, node: SingleNode) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      const setCenter = () => {
        lineStart.value = {
          x: pan.value.x + node.x + node.width / 2,
          y: pan.value.y + node.y + node.height / 2,
        };
      };

      colorChanges.value.push({ node, color: VALID_ENDPOINT_OUTLINE });

      // Get all nodes that contain the given point
      const getNodesInRange = (point: MouseEvent) => {
        return nodes.value
          .filter(isSingleNode) // we can't make connections to group nodes
          .filter((n) => {
            const ul = { x: n.x + pan.value.x, y: n.y + pan.value.y }; // upper left corner
            const lr = { x: ul.x + n.width, y: ul.y + n.height }; // lower right corner
            return n !== node && point.x > ul.x && point.y > ul.y && lr.x > point.x && lr.y > point.y;
          });
      };

      const getRelationship = (a: ProvenanceNode, b: ProvenanceNode) => {
        let defaultRelationshipMap = cachedConnections.value[a.type];
        if (!defaultRelationshipMap) {
          defaultRelationshipMap = cachedConnections.value[a.type] = {};
        }

        let relationship =  defaultRelationshipMap[b.type];
        if (!relationship) {
          relationship = defaultRelationshipMap[b.type] = getDefaultRelationshipType(a.type, b.type);
        }

        return relationship;
      };


      let targetNode: SingleNode | null = null;
      const disposer = addEventListeners({
        mousemove: (ev: MouseEvent) => {
          lineEnd.value = ev;
          setCenter();
          const nodesInRange = getNodesInRange(ev);

          // reset the color of the previously selected node
          // TODO this will cause a bug if the node was initially colored something else
          if (targetNode) {
            colorChanges.value.push({ node: targetNode, color: NODE_OUTLINE });
            targetNode = null;
          }

          if (nodesInRange.length === 0) {
            return;
          }

          const top = targetNode = nodesInRange[nodesInRange.length - 1];
          const a = node.provenanceNode;
          const b = top.provenanceNode;

          const relationship = getRelationship(a, b);
          const valid = isValidRelationship(a, b, relationship);
          const color = valid ? VALID_ENDPOINT_OUTLINE : INVALID_ENDPOINT_OUTLINE;
          colorChanges.value.push({ node: targetNode, color });
        },
        mouseup: async (ev: MouseEvent) => {
          if (ev.which !== 3) {
            return;
          }

          disposer.dispose();
          lineStart.value = null;
          lineEnd.value = null;

          colorChanges.value.push({ node, color: NODE_OUTLINE });
          if (targetNode) {
            colorChanges.value.push({ node: targetNode, color: NODE_OUTLINE });
          }

          const nodesInRange = getNodesInRange(ev);
          if (nodesInRange.length === 0) {
            return;
          }

          const nodeToMakeConnection = nodesInRange[nodesInRange.length - 1];
          const a = node.provenanceNode;
          const b = nodeToMakeConnection.provenanceNode;
          const relationship = getRelationship(a, b);

          const connection = createRelationship(a, b, relationship);
          if (!connection.can) {
            return;
          }

          const result = await makeRequest(() => backend.updateOrCreateDependency(connection.connection));
          if (result.result !== 'success') {
            return;
          }

          dependencies.value.push(connection.connection);
          renderGraph();
        },
      });
    }

    function createNewNode(n: ProvenanceNode): SingleNode {
      const sourceId = n.id;

      const source = highLevelNodeLookup.value[sourceId];
      const moreLeftToShow = source.incoming.some((connection) => {
        return !nodesToShow.value[connection.source.id];
      }) || source.outgoing.some((connection) => {
        return !nodesToShow.value[connection.target.id];
      });

      const text = getLabel(n, simulationStudyLookup.value, modelVersionLookup.value);
      const { x, y } = nodeLookup.value[sourceId] ? nodeLookup.value[sourceId] : pointToPlaceNode.value;
      const node: SingleNode = {
        isGroup: false,
        id: sourceId,
        text,
        actionText: moreLeftToShow ? 'See more' : undefined,
        type: n.type,
        studyId: n.studyId,
        hullGroup: n.studyId,
        stroke: NODE_OUTLINE,
        x,
        y,
        vx: 0,
        vy: 0,
        index: 0,
        provenanceNode: n,
        rx: getClassification(n.type) === 'entity' ? 10 : 0,
        // width and height are essential
        // TODO add requirement to type file
        // they are used in the other js files
        // ALSO, * 8 just kinda works well and 10 is the padding
        width: text.length * 8 + 10,
        height: NODE_HEIGHT,
        onDidRightClick: (e: MouseEvent) => {
          nodeRightClick(e, node);
        },
        onDidMousedown: (e: MouseEvent) => {
          // Stop the pan/zoom tool from panning when the user clicks on a node
          e.stopPropagation();
        },
        onDidClick: (e: MouseEvent) => {
          colorChanges.value.push({ node, color: SELECTED_NODE_OUTLINE });

          if (selectedNode.value) {
            const selected = nodeLookup.value[selectedNode.value.id];
            if (selected && !selected.isGroup) {
              colorChanges.value.push({ node: selected, color: NODE_OUTLINE });
            }
          }

          if (selectedNode.value === n) {
            selectedNode.value = null;
          } else {
            selectedNode.value = n;
          }
        },
        onDidActionClick: (e) => {
          // Stop propagation so that the onDidClick event above is not fired
          e.stopPropagation();

          const highLevel = highLevelNodeLookup.value[node.id];

          // Show all incoming connections
          highLevel.incoming.forEach((connection) => {
            nodesToShow.value[connection.source.id] = true;
          });

          // And show all outgoing connections
          highLevel.outgoing.forEach((connection) => {
            nodesToShow.value[connection.target.id] = true;
          });

          pointToPlaceNode.value = node;
          renderGraph();
        },
      };

      return node;
    }

    function renderGraph() {
      const newLinks: Link[] = [];
      const newNodes: Node[] = [];
      const collapsedNodes: { [studyId: number]: GroupNode } = {};

      // We don't care about any nodes that don't need to be shown.
      const filtered = provenanceNodes.value.filter((n) => nodesToShow.value[n.id]);

      let studyIds = filtered.map((n) => n.studyId).filter(isDefined);
      studyIds = Array.from(new Set(studyIds)); // get all unique study IDs

      // Remove studies that are expanded
      studyIds = studyIds.filter((studyId) => !expanded.value[studyId]);

      // First, create all of the simulation study nodes.
      // These are the collapsed nodes. We only need to create one per simulation study.
      studyIds.forEach((studyId) => {
        // So every node needs a unique ID. The nodes stored in the database all have a unique ID but collapsed
        // nodes to not have this attribute. Therefore, we generate a unique ID based off the studyId. This also allows
        // us to easily lookup the location of the collapsed node when re-rendering.
        const id = '' + studyId;
        const point = nodeLookup.value[id] ? nodeLookup.value[id] : pointToPlaceNode.value;
        const node: GroupNode = {
          ...point,
          isGroup: true,
          studyId,
          id,
          index: 0,
          vx: 0,
          vy: 0,
          stroke: SIMULATION_STUDY_STROKE,
          rx: 0,
          text: `M${studyId}`,
          width: SIMULATION_STUDY_WIDTH,
          height: NODE_HEIGHT,
          onDidDblclick: () => {
            expanded.value[studyId] = true;
            pointToPlaceNode.value = node;
            renderGraph();
          },
        };

        collapsedNodes[studyId] = node;
        newNodes.push(node);
      });

      filtered.forEach((n) => {
        const sourceId = n.id;

        const info = highLevelNodeLookup.value[sourceId];
        info.outgoing.forEach((c) => {
          const targetId = c.target.id;

          if (!nodesToShow.value[targetId]) {
            return;
          }

          const determineLinkId = (id: string, studyId: number | undefined) => {
            if (studyId === undefined || expanded.value[studyId]) {
              return id;
            }

            return collapsedNodes[studyId].id;
          };

          const source = determineLinkId(sourceId, c.source.node.studyId);
          const target = determineLinkId(targetId, c.target.node.studyId);

          // This happens for nodes in the same strudy when the study hasn't been expanded
          if (target === source) {
            return;
          }

          const link: Link = {
            source,
            target,
            color: c.color,
            onDidClick: () => {
              if (selectedConnection.value === c) {
                cancelRelationshipSelection();
                return;
              }

              selectedConnection.value = c;

              const a = c.source.node;
              const b = c.target.node;

              const aRules = relationshipRules[a.type];
              if (!aRules) {
                return;
              }

              const rules = aRules[b.type];
              if (!rules) {
                return;
              }

              currentRelationship.value = c.relationship;
              possibleRelationships.value = rules.map((rule) => {
                if (typeof rule === 'string') {
                  return rule;
                }

                return rule.relationship;
              });
            },
          };

          newLinks.push(link);
        });
      });

      filtered.forEach((n) => {
        // don't add nodes that are in a study that isn't expanded
        if (n.studyId !== undefined && !expanded.value[n.studyId]) {
          return;
        }

        newNodes.push(createNewNode(n));
      });

      // Make sure to reset this since we are done rendering
      pointToPlaceNode.value = { x: 0, y: 0 };

      // This needs to happen at the end since we use the position information of the nodes
      // If we reset at the beginning, that information wouldn't be there
      nodes.value = newNodes;
      links.value = newLinks;
    }

    async function addNode() {
      const node: ProvenanceNode = {
        type: 'ModelBuildingActivity',
        id: uniqueId(),
        keys: [],
        values: [],
      };

      const result = await makeRequest(() => backend.updateOrCreateNode(node));
      if (result.result !== 'success') {
        return;
      }

      provenanceNodes.value.push(node);
      selectedNode.value = node;

      nodesToShow.value[node.id] = true;
      renderGraph();
    }

    function cancelRelationshipSelection() {
      selectedConnection.value = null;
      currentRelationship.value = null;
      possibleRelationships.value = null;
    }

    async function changeRelationship(relationship: DependencyType) {
      if (!selectedConnection.value) {
        return;
      }

      const originalConnection = selectedConnection.value.original;

      const a = selectedConnection.value.source.node;
      const b = selectedConnection.value.target.node;

      const cached = cachedConnections.value[a.type] = cachedConnections.value[a.type] || {};
      cached[b.type] = relationship;

      const newProperties = {
        ...originalConnection.properties,
        type: relationship,
      };

      const result = await makeRequest(() => backend.updateOrCreateDependency({
        source: originalConnection.source,
        target: originalConnection.target,
        properties: newProperties,
      }));
      if (result.result !== 'success') {
        return;
      }

      // This feels a bit messy
      // Set the relationship
      // Set the relationship of the actual data
      // Then render the graph again
      currentRelationship.value = relationship;
      originalConnection.properties = newProperties;
      renderGraph();
      cancelRelationshipSelection();
    }

    async function deleteRelationship() {
      if (!selectedConnection.value) {
        return;
      }

      const connection = selectedConnection.value;
      const result = await makeRequest(() => backend.deleteDependency(connection.properties.id));
      if (result.result !== 'success') {
        return;
      }

      dependencies.value = dependencies.value.filter((dependency) => {
        return dependency.properties.id !== connection.properties.id;
      });

      renderGraph();
      cancelRelationshipSelection();
    }

    function deselectNode() {
      selectedNode.value = null;
    }

    async function deleteNode() {
      if (!selectedNode.value) {
        return;
      }

      const selected = selectedNode.value;

      // This request will delete all of the dependency relationships
      // It will also delete information relationships and nodes
      const result = await makeRequest(() => backend.deleteNode(selected.id));
      if (result.result !== 'success') {
        return;
      }

      // We have to delte the same data that the backend deletes
      provenanceNodes.value = provenanceNodes.value.filter((n) => {
        return n.id !== selected.id;
      });

      const nodeIds = new Set(provenanceNodes.value.map(({ id }) => id));
      dependencies.value = dependencies.value.filter((dependency) => {
        return nodeIds.has(dependency.target) && nodeIds.has(dependency.source);
      });

      selectedNode.value = null;
      renderGraph();
    }

    async function validateConnections(node: ProvenanceNode) {
      // Here we are revalidating all of the connections to see if they are still valid
      // If the type of node changed, they may no longer be valid
      const { outgoing, incoming } = highLevelNodeLookup.value[node.id];
      const toRemove = new Set<string>();

      [...incoming, ...outgoing].forEach((c) => {
        if (isValidRelationship(c.source.node, c.target.node, c.relationship)) {
          return;
        }

        toRemove.add(c.properties.id);
      });

      if (toRemove.size === 0) {
        return;
      }

      for (const id of toRemove) {
        logger.info('Deleting dependency: ' + id);
        makeRequest(() => backend.deleteDependency(id));
      }

      dependencies.value = dependencies.value.filter((dependency) => {
        return !toRemove.has(dependency.properties.id);
      });

      debouncedRenderGraph();
    }

    function editNode<K extends keyof ProvenanceNode>(node: ProvenanceNode, key: K) {
      debouncedUpdateOrCreateNode(node);
      debouncedRenderGraph();

      // Only validate the connections if the type of node changed.
      if (key === 'type') {
        validateConnections(node);
      }
    }

    onMounted(() => {
      makeRequest(backend.getStudies, (result) => {
        simulationStudies.value = result.items;
      });

      makeRequest(backend.getNodes, (result) => {
        provenanceNodes.value = result.items;
      });

      makeRequest(backend.getNodeDependencies, (result) => {
        dependencies.value = result.items;
      });
    });

    return {
      dependencies,
      version,
      showHelp,
      showEditTools,
      height,
      width,
      links,
      currentRelationship,
      nodes,
      lineStart,
      lineEnd,
      pan,
      fabActions,
      searchItems,
      expandStudy,
      legendProps,
      showProvenanceGraph,
      stopEdit: () => {
        showEditTools.value = false;
      },
      openStudy: (result: SearchItem) => {
        if (result.studyId === undefined) {
          context.root.$notification.open({
            message: 'Please assign a study ID first.',
            position: 'is-top-right',
            type: 'is-warning',
          });

          return;
        }

        if (simulationStudyLookup.value[result.studyId] === undefined) {
          context.root.$notification.open({
            message: 'No study exists for this node.',
            position: 'is-top-right',
            type: 'is-warning',
          });

          return;
        }

        selectedStudy.value = simulationStudyLookup.value[result.studyId];
      },
      hullDblclick: (d: D3Hull) => {
        expanded.value[d.group] = false;

        const point = { x: 0, y: 0 };
        d.nodes.forEach((n) => {
          point.x += n.x;
          point.y += n.y;
        });

        // Place the new node at the center of all of the nodes its consumming
        point.x /= d.nodes.length;
        point.y /= d.nodes.length;

        pointToPlaceNode.value = point;

        renderGraph();
      },
      colorChanges,
      createStudy,
      addNode,
      selectedStudy,
      cancelSelectedStudy,
      deleteSelectedStudy,
      saveSelectedStudy,
      selectedNode,
      deselectNode,
      deleteNode,
      editNode,
      changeRelationship,
      possibleRelationships,
      cancelRelationshipSelection,
      deleteRelationship,
      simulationStudies,
    };
  },
});
</script>

<style lang="scss" scoped>
.cards {
  width: 350px;
  max-height: 100vh;
  overflow-y: auto;
  padding: 20px 1px;
}

.search {
  width: 450px;
  // 40 px for margin/padding and 60px for the information button
  max-height: calc(100vh - 100px);
}

.spacer {
  margin: 10px 0;
}

.overlay {
  position: absolute;
  margin: 0 20px;

  // So that the overlay overlays everything else
  z-index: 5;
  top: 0;
  left: 0;
  right: 0;
  display: flex;
  align-items: flex-start;
  pointer-events: none;
}

.overlay-child {
  pointer-events: auto;
}

.overlay-child:not(.cards) {
  margin-top: 20px;
}

.clear-button {
  margin: 0 10px;
}

.version {
  position: absolute;
  left: 25px;
  bottom: 15px;
  color: rgba(0, 0, 0, 0.5);
}
</style>
